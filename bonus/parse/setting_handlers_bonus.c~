/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   setting_handlers_bonus.c                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: mlebard <mlebard@student.42.fr>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/03/19 13:21:40 by mlebard           #+#    #+#             */
/*   Updated: 2021/05/07 19:30:46 by mlebard          ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../include/cub3d_bonus.h"

int		handle_resolution(char **args, t_cub *cub)
{
//	t_pos	screen;

	if (ft_argcount(args) != 4)
		return (setting_error(cub, args, ERR_ARG_NB, args[0]));
	if (ft_argcheck_each(&args[1], &ft_isdigit) == 0)
		return (setting_error(cub, args, ERR_BAD_ARG, args[0]));
	cub->res.x = ft_atoi(args[1]);
	cub->res.y = ft_atoi(args[2]);
	if (cub->res.x <= 0 || cub->res.y <= 0)
		return (setting_error(cub, args, ERR_BAD_ARG, args[0]));
	// Only in Linux APPARENTLY???
	/*
	mlx_get_screen_size(cub->mlx, &screen.x, &screen.y);
	cub->set->resx = ft_islower(screen.x, cub->set->resx);
	cub->set->resy = ft_islower(screen.y, cub->set->resy);
	*/
	return (SUCCESS);
}

int		handle_skybox(char **args, t_cub *cub)
{
	int	ret;

	if (ft_strcmp(args[0], "SB") != 0)
		return (ERR_WRONG_ID);
	if (ft_argcount(args) != 3)
		return (setting_error(cub, args, ERR_ARG_NB, args[0]));
	if ((ret = assign_texture(args, cub, &cub->tex_sky)) != 0)
		return (setting_error(cub, args, ret, args[0]));
	return (SUCCESS);
}

int		assign_rgb(char *rgb_str, int *dest)
{
	int		rgb;
	char	*temp;

	rgb = 0;
	temp = rgb_str;
	while (temp)
	{
		temp = ft_strchr(temp, ',');
		if (temp && *(++temp) == ',')
			return (ERR_BAD_ARG);
	}
	if ((rgb = str_to_rgb(rgb_str)) == -1)
		return (ERR_BAD_ARG);
	*dest = rgb;
	return (SUCCESS);
}

int		handle_minimap(char **args, t_cub *cub)
{
	int	ret;

	if (ft_argcount(args) != 8)
		return (setting_error(cub, args, ERR_ARG_NB, args[0]));
	if (ft_strcheck_each(args[1], &ft_isdigit) && ft_strcheck_each(args[2],
				&ft_isdigit) && ft_strcheck_each(args[3], &ft_isdigit))
	{
		cub->mini->ratio.x = ft_atoi(args[1]);
		cub->mini->ratio.y = ft_atoi(args[2]);
		cub->mini->tilesize = ft_atoi(args[3]);
	}
	else
		return (setting_error(cub, args, ERR_BAD_ARG, args[0]));
	if (cub->mini->ratio.x <= 0 || cub->mini->ratio.y <= 0 ||
			cub->mini->tilesize <= 0)
		return (setting_error(cub, args, ERR_BAD_ARG, args[0]));
	if ((ret = assign_rgb(args[4], &cub->mini->wall_color)) != SUCCESS)
		return (setting_error(cub, args, ret, args[0]));
	if ((ret = assign_rgb(args[5], &cub->mini->floor_color)) != SUCCESS)
		return (setting_error(cub, args, ret, args[0]));
	if ((ret = assign_rgb(args[6], &cub->mini->player_color)) != SUCCESS)
		return (setting_error(cub, args, ret, args[0]));
	return (SUCCESS);
}

int		handle_textures(int fd, t_cub *cub, int limit, t_img *path)
{
	int	count;
	int	ret;
	int	texnbr;
	char	**args;

	count = 0;
	args = NULL;
	if (open_set(fd) < 0)
		return (setting_error(cub, args, ERR_SET_OPEN, "TEXTURES"));
	while (count < limit)
	{
		if ((ret = get_next_setting(&args, fd)) < 0)
			return (setting_error(cub, args, ret, "TEXTURES"));
		if ((texnbr = check_tex(args[0], limit, path)) < 0)
			return (setting_error(cub, args, texnbr, "TEXTURES"));
		if ((ret = assign_texture(args, cub, &path[texnbr])) != 0)
			return (setting_error(cub, args, ret, "TEXTURES"));
		count++;
		ft_freeargs(args, ft_argcount(args));
		args = NULL;
	}
	if (close_set(fd) < 0)
		return (setting_error(cub, args, ERR_SET_CLOSE, "TEXTURES"));
	return (1);
}

int		add_anim(char **args, int limit, t_img *texpath)
{
	int		tex1;
	int		tex2;
	double	delay;

	if (ft_argcount(args) != 4)
		return (ERR_ARG_NB);
	if ((tex1 = get_tex_nbr(args[0], limit)) < 0)
		return (ERR_BAD_ARG);
	if ((tex2 = get_tex_nbr(args[1], limit)) < 0)
		return (ERR_BAD_ARG);
	if (ft_isfloat(args[2]) != 1)
		return (ERR_BAD_ARG);
	delay = atof(args[2]);
	if (delay == 0)
		return (ERR_BAD_ARG);
	texpath[tex1].next_tex = &texpath[tex2];
	texpath[tex1].delay = (int)(CLOCKS_PER_SEC * delay);
	return (SUCCESS);
}

int		handle_anim(int fd, t_cub *cub, int limit, t_img *texpath)
{
	int		ret;
	char	**args;

	args = NULL;
	if (open_set(fd) < 0)
		return (setting_error(cub, args, ERR_SET_OPEN, cub->set_id));
	while (1)
	{
		if ((ret = get_next_setting(&args, fd)) < 0)
			return (setting_error(cub, args, ret, cub->set_id));
		if (ft_strcmp(args[0], "}") == 0)
			break;
		if ((ret = add_anim(args, limit, texpath)) < 0)
			return (setting_error(cub, args, ret, cub->set_id));
		ft_freeargs(args, ft_argcount(args));
	}
	if (ft_argcount(args) != 2)
		return (setting_error(cub, args, ERR_SET_CLOSE, cub->set_id));
	ft_freeargs(args, ft_argcount(args));
	return (0);
}

int		assign_sprite_info(char **args, t_cub *cub, int typenbr)
{
	t_sprite	temp;
	int			ret;

	if (ft_argcount(args) != 8)
		return (ERR_ARG_NB);
	if ((ret = set_sprite(args, &temp, cub)) != SUCCESS)
		return (ret);
	cub->sp_type[typenbr] = temp;
	return (SUCCESS);
}

int		handle_sprite_info(int fd, t_cub *cub)
{
	int	count;
	int	ret;
	int	typenbr;
	char	**args;

	count = 0;
	args = NULL;
	if (open_set(fd) < 0)
		return (setting_error(cub, args, ERR_SET_OPEN, cub->set_id));
	while (count < cub->sp_type_nb)
	{
		if ((ret = get_next_setting(&args, fd)) < 0)
			return (setting_error(cub, args, ret,"SPRITE INFO"));
		if ((typenbr = check_sprite_type(args[0], cub)) < 0)
			return (setting_error(cub, args, typenbr, "SPRITE INFO"));
		if ((ret = assign_sprite_info(args, cub, typenbr)) != 0)
			return (setting_error(cub, args, ret, "SPRITE INFO"));
		count++;
		ft_freeargs(args, ft_argcount(args));
		args = NULL;
	}
	if (close_set(fd) < 0)
		return (setting_error(cub, args, ERR_SET_CLOSE, "SPRITE INFO"));
	return (SUCCESS);
}

int		add_sprite_from_type(char **args, t_cub *cub)
{
	t_sprite	temp;
	int			typenbr;

	if (ft_argcount(args) != 4)
		return (ERR_ARG_NB);
	ft_bzero(&temp, sizeof(t_sprite));
	if ((typenbr = get_tex_nbr(args[0], cub->sp_type_nb)) < 0)
		return (typenbr);
	ft_memcpy(&temp, &cub->sp_type[typenbr], sizeof(t_sprite));
	if (ft_isfloat(args[1]) == 1 && ft_isfloat(args[2]) == 1)
		set_sprite_posxy(ft_atof(args[1]), ft_atof(args[2]), &temp);
	else
		return (ERR_BAD_ARG);
	temp.id = ++cub->sp_nb;
	if (temp.event != 0)
		temp.ev_id = ++cub->event_count;
	if (add_sprite(temp, cub) < 0)
		return (ERR_MALLOC);
	if (temp.event != 0)
	{
		if (add_event_from_sprite(cub, temp) < 0)
			return (ERR_MALLOC);
	}
	return (SUCCESS);
}

int		handle_sprites(int fd, t_cub *cub)
{
	int		ret;
	char	**args;

	args = NULL;
	if (open_set(fd) < 0)
		return (setting_error(cub, args, ERR_SET_OPEN, cub->set_id));
	while (1)
	{
		if ((ret = get_next_setting(&args, fd)) < 0)
			return (setting_error(cub, args, ret, cub->set_id));
		if (ft_strcmp(args[0], "}") == 0)
			break;
		if ((ret = add_sprite_from_type(args, cub)) < 0)
			return (setting_error(cub, args, ret, cub->set_id));
		ft_freeargs(args, ft_argcount(args));
	}
	if (ft_argcount(args) != 2)
		return (setting_error(cub, args, ERR_SET_CLOSE, cub->set_id));
	ft_freeargs(args, ft_argcount(args));
	return (1);
}

int		add_teleporter(char **args, t_cub *cub)
{
	t_sprite	temp;
	t_dpos		tp;
	int			ret;
	int			typenbr;

	if (ft_argcount(args) != 6)
		return (ERR_ARG_NB);
	ft_bzero(&temp, sizeof(t_sprite));
	printf("arg[0] = %s\n", args[0]);
	if ((typenbr = get_tex_nbr(args[0], cub->sp_type_nb)) < 0)
		return (typenbr);
	ft_memcpy(&temp, &cub->sp_type[typenbr], sizeof(t_sprite));
	if (ft_isfloat(args[1]) == 1 && ft_isfloat(args[2]) == 1)
		set_sprite_posxy(ft_atof(args[1]), ft_atof(args[2]), &temp);
	else
		return (ERR_BAD_ARG);
	temp.id = ++cub->sp_nb;
	temp.ev_id = ++cub->event_count;
	if (ft_isfloat(args[3]) == 1 && ft_isfloat(args[4]) == 1)
	{
		tp.x = ft_atof(args[3]);
		tp.y = ft_atof(args[4]);
	}
	if ((ret = add_sprite(temp, cub)) < 0)
		return (ret);
	if ((ret = add_event_teleport(cub, temp, tp)) < 0)
		return (ret);
	return (SUCCESS);
}

int		handle_teleporters(int fd, t_cub *cub)
{
	int		ret;
	char	**args;

	args = NULL;
	if (open_set(fd) < 0)
		return (setting_error(cub, args, ERR_SET_OPEN, cub->set_id));
	while (1)
	{
		if ((ret = get_next_setting(&args, fd)) < 0)
			return (setting_error(cub, args, ret, cub->set_id));
		if (ft_strcmp(args[0], "}") == 0)
			break ;
		if ((ret = add_teleporter(args, cub)) < 0)
			return (setting_error(cub, args, ret, cub->set_id));
		ft_freeargs(args, ft_argcount(args));
	}
	if (ft_argcount(args) != 2)
		return (setting_error(cub, args, ERR_SET_CLOSE, cub->set_id));
	ft_freeargs(args, ft_argcount(args));
	return (SUCCESS);
}

/*
int		handle_sprites_deco(int fd, t_cub *cub)
{
	int		ret;
	char	**args;

	args = NULL;
	if (open_set(fd) <= 0)
		return (setting_error(args, ERR_SET_OPEN, cub->set_id));
	while (1)
	{
		if ((ret = get_next_setting(&args, fd)) < 0)
			return (setting_error(args, ret, cub->set_id));
		if (ft_strcmp(args[0], "}") == 0)
			break;
		if ((ret = add_sprite_deco(args, cub)) < 0)
			return (setting_error(args, ret, cub->set_id));
		ft_freeargs(args, ft_argcount(args));
	}
	if (ft_argcount(args) != 2)
		return (setting_error(args, ERR_SET_CLOSE, cub->set_id));
	ft_freeargs(args, ft_argcount(args));
	return (1);
}

int		handle_sprites_collect(int fd, t_cub *cub)
{
	int		ret;
	char	**args;

	args = NULL;
	if (open_set(fd) <= 0)
		return (setting_error(args, ERR_SET_OPEN, cub->set_id));
	while (1)
	{
		if ((ret = get_next_setting(&args, fd)) < 0)
			return (setting_error(args, ret, cub->set_id));
		if (ft_strcmp(args[0], "}") == 0)
			break;
		if ((ret = add_sprite_collect(args, cub)) < 0)
			return (setting_error(args, ret, cub->set_id));
		ft_freeargs(args, ft_argcount(args));
	}
	if (ft_argcount(args) != 2)
		return (setting_error(args, ERR_SET_CLOSE, cub->set_id));
	ft_freeargs(args, ft_argcount(args));
	return (1);
}


int		handle_sprites_remove(int fd, t_cub *cub)
{
	int		ret;
	char	**args;

	args = NULL;
	if (open_set(fd) <= 0)
		return (setting_error(args, ERR_SET_OPEN, cub->set_id));
	while (1)
	{
		if ((ret = get_next_setting(&args, fd)) < 0)
			return (setting_error(args, ret, cub->set_id));
		if (ft_strcmp(args[0], "}") == 0)
			break;
		if ((ret = add_sprite_remove(args, cub)) < 0)
			return (setting_error(args, ret, cub->set_id));
		ft_freeargs(args, ft_argcount(args));
	}
	if (ft_argcount(args) != 2)
		return (setting_error(args, ERR_SET_CLOSE, cub->set_id));
	ft_freeargs(args, ft_argcount(args));
	return (1);
}
*/
